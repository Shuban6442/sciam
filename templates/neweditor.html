<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SCIAM - Session {{ session_id }}</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.34.1/min/vs/loader.js"></script>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --accent: #3b82f6;
      --success: #10b981;
      --error: #ef4444;
      --chat-bg: #0b1220;
      --chat-bubble-me: #2563eb;
      --chat-bubble-other: #374151;
      --warning: #f59e0b;
    }
    body { margin: 0; font-family: system-ui, sans-serif; background: var(--bg); color: var(--text); }
    .topbar { display: flex; justify-content: space-between; padding: 10px 16px; background: #111827; border-bottom: 1px solid #2a3342; }
    .brand { display: flex; gap: 10px; align-items: center; }
    .session-code { background: #1f2937; padding: 4px 8px; border-radius: 6px; font-family: monospace; }
    .actions { display: flex; gap: 8px; }
    .container { display: flex; height: calc(100vh - 50px); }
    .left { flex: 1; display: flex; flex-direction: column; }
    #editor { flex: 1; }
    .toolbar { padding: 8px; background: #111827; display: flex; gap: 8px; border-top: 1px solid #2a3342; align-items: center; }
    .btn { padding: 8px 16px; border-radius: 6px; border: 1px solid #2a3342; background: #1f2937; color: var(--text); cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 6px; }
    .btn:hover { background: #374151; }
    .btn.primary { background: #2563eb; border-color: #2563eb; }
    .btn.primary:hover { background: #1d4ed8; }
    .btn.success { background: var(--success); border-color: var(--success); }
    .btn.error { background: var(--error); border-color: var(--error); }
    .btn.warning { background: var(--warning); border-color: var(--warning); color: #000; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    #output { padding: 12px; background: #0b1220; border-top: 1px solid #2a3342; min-height: 100px; max-height: 200px; overflow-y: auto; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 14px; }
    #participantsDrawer { width: 400px; border-left: 1px solid #2a3342; background: #0b1220; display: flex; flex-direction: column; }
    #plist { list-style: none; margin: 0; padding: 12px; flex: 1; }
    #plist li { display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 8px; border: 1px solid #2a3342; border-radius: 6px; background: #111827; }
    .participant-info { display: flex; flex-direction: column; flex: 1; }
    .participant-name { font-weight: 500; }
    .participant-role { font-size: 12px; color: #9ca3af; }
    .participant-audio { display: flex; align-items: center; gap: 8px; font-size: 12px; }
    .audio-indicator { width: 8px; height: 8px; border-radius: 50%; background: #6b7280; }
    .audio-indicator.speaking { background: var(--success); animation: pulse 1s infinite; }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    .participant-actions { display: flex; gap: 4px; }
    .action-btn { padding: 4px 8px; font-size: 12px; border-radius: 4px; border: 1px solid #374151; background: #1f2937; color: var(--text); cursor: pointer; }
    .action-btn:hover { background: #374151; }
    #writerBanner { text-align: center; padding: 8px; background: #1e3a8a; color: #fff; font-weight: bold; display: none; }
    #audioSection { padding: 12px; border-top: 1px solid #2a3342; background: #111827; }
    .audio-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .audio-participant { padding: 8px 12px; margin: 4px 0; background: #1f2937; border-radius: 6px; display: flex; justify-content: space-between; align-items: center; }
    .audio-status { font-size: 11px; padding: 2px 6px; border-radius: 4px; background: #6b7280; color: white; }
    .audio-status.connected { background: var(--success); }
    .audio-status.muted { background: var(--error); }
    #audioControls { padding: 12px; background: #111827; border-top: 1px solid #2a3342; display: flex; align-items: center; gap: 12px; justify-content: center; }
    #muteButton { display: flex; align-items: center; gap: 8px; min-width: 120px; justify-content: center; background: #374151; }
    #muteButton.muted { background: var(--error); border-color: var(--error); }
    #muteButton:not(.muted) { background: var(--success); border-color: var(--success); }
    .connection-status { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #9ca3af; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #6b7280; }
    .status-dot.connected { background: var(--success); }
    .status-dot.disconnected { background: var(--error); }
    #audioLevel { width: 80px; height: 4px; background: #374151; border-radius: 2px; overflow: hidden; }
    #audioLevelFill { height: 100%; width: 0%; background: var(--success); transition: width 0.1s; }
    .meeting-stats { display: flex; gap: 16px; font-size: 12px; color: #9ca3af; }

    /* Input Controls Styles */
    .input-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .input-controls input {
      padding: 8px 12px;
      border: 1px solid #374151;
      border-radius: 4px;
      background: #1f2937;
      color: white;
      width: 200px;
      font-family: system-ui, sans-serif;
    }

    .input-controls input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .input-controls input:enabled {
      border-color: #059669;
    }

    .input-controls input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .input-controls input::placeholder {
      color: #9ca3af;
    }

    /* Chat Styles */
    .drawer-tabs {
      display: flex;
      background: #111827;
      border-bottom: 1px solid #2a3342;
    }
    
    .tab-btn {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
    }
    
    .tab-btn.active {
      background: #1e293b;
      border-bottom: 2px solid #3b82f6;
    }
    
    .tab-content {
      display: none;
      flex: 1;
      overflow: hidden;
    }
    
    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    .chat-header {
      padding: 12px;
      border-bottom: 1px solid #2a3342;
      background: #111827;
    }
    
    .chat-messages {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .chat-message {
      max-width: 80%;
      padding: 8px 12px;
      border-radius: 12px;
      position: relative;
      word-wrap: break-word;
    }
    
    .chat-message.me {
      align-self: flex-end;
      background: var(--chat-bubble-me);
      border-bottom-right-radius: 4px;
    }
    
    .chat-message.other {
      align-self: flex-start;
      background: var(--chat-bubble-other);
      border-bottom-left-radius: 4px;
    }
    
    .message-sender {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 2px;
      opacity: 0.9;
    }
    
    .message-text {
      margin: 4px 0;
    }
    
    .message-time {
      font-size: 10px;
      opacity: 0.7;
      text-align: right;
      margin-top: 4px;
    }
    
    .chat-input-container {
      padding: 12px;
      border-top: 1px solid #2a3342;
      background: #111827;
    }
    
    .chat-input-group {
      display: flex;
      gap: 8px;
    }
    
    #chatInput {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #374151;
      border-radius: 20px;
      background: #1f2937;
      color: var(--text);
      outline: none;
    }
    
    #chatInput:focus {
      border-color: #3b82f6;
    }
    
    #sendChatBtn {
      padding: 8px 16px;
      border-radius: 20px;
      background: #2563eb;
      color: white;
      border: none;
      cursor: pointer;
    }
    
    #sendChatBtn:hover {
      background: #1d4ed8;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <span style="font-weight: bold; color: #3b82f6;">SIREN</span>
      <span class="session-code">Session: {{ session_id }}</span>
      <div class="connection-status">
        <span id="statusDot" class="status-dot connected"></span>
        <span id="statusText">Connected</span>
      </div>
    </div>
    <div class="actions">
      <button id="helpBtn" class="btn" title="Help">‚ùì Help</button>
    </div>
  </div>

  <div id="writerBanner">‚úèÔ∏è You are the Writer - You can edit the code</div>

  <div class="container">
    <div class="left">
      <div id="editor"></div>
      <div class="toolbar">
        <button id="runBtn" class="btn primary">‚ñ∂ Run Code</button>
        <button id="clearBtn" class="btn">üóëÔ∏è Clear Output</button>
        <div style="flex: 1;"></div>
        
        <!-- Static Input Box -->
        <div class="input-controls">
          <input type="text" id="staticInput" placeholder="Run code to enable input..." disabled />
          <button id="sendInputBtn" class="btn" style="background: #059669;" disabled>Send Input</button>
        </div>
        
        <button id="settingsBtn" class="btn">‚öôÔ∏è Settings</button>
      </div>
      <div id="output"></div>

      <div id="audioControls">
        <div class="meeting-stats">
          <span>Participants: <span id="participantCount">1</span></span>
          <span>Audio: <span id="audioStatus">Connected</span></span>
        </div>
        <div style="flex: 1;"></div>
        <button id="muteButton" class="btn">
          <span id="muteIcon">üé§</span>
          <span id="muteText">Mute</span>
        </button>
        <div id="audioLevel">
          <div id="audioLevelFill"></div>
        </div>
        <div style="flex: 1;"></div>
        <div class="meeting-stats">
          <span>Connected: <span id="peerCount">0</span></span>
        </div>
      </div>
    </div>

    <!-- Right Drawer with Tabs -->
    <div id="participantsDrawer">
      <div class="drawer-tabs">
        <button class="tab-btn active" data-tab="participants">üë• Participants</button>
        <button class="tab-btn" data-tab="chat">üí¨ Chat</button>
      </div>
      
      <!-- Participants Tab -->
      <div id="participantsTab" class="tab-content active">
        <div style="padding: 12px; border-bottom: 1px solid #2a3342;">
          <h3 style="margin: 0;">Participants</h3>
        </div>
        <ul id="plist"></ul>
        
        <div id="audioSection">
          <div class="audio-header">
            <h4 style="margin: 0;">Voice Chat</h4>
            <span id="audioCount" style="font-size: 12px; color: #9ca3af;">0 users</span>
          </div>
          <div id="audioList"></div>
        </div>
      </div>
      
      <!-- Chat Tab -->
      <div id="chatTab" class="tab-content">
        <div class="chat-header">
          <h3 style="margin: 0;">Group Chat</h3>
        </div>
        <div id="chatMessages" class="chat-messages">
          <div style="text-align: center; color: #9ca3af; padding: 20px;">
            No messages yet. Start a conversation!
          </div>
        </div>
        <div class="chat-input-container">
          <div class="chat-input-group">
            <input type="text" id="chatInput" placeholder="Type a message..." maxlength="500" />
            <button id="sendChatBtn">Send</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const socket = io();
    const sessionId = "{{ session_id }}";
    const urlParams = new URLSearchParams(window.location.search);
    const myName = urlParams.get("name") || "Anonymous";

    let mySid = null;
    let writerId = null;
    let hostId = null;
    let editor;
    
    // Code execution state
    let currentProcessId = null;
    
    // Audio State
    let isAudioConnected = false;
    let isMuted = false;
    let localStream = null;
    let pcPeers = {};
    let audioContext = null;
    let analyser = null;
    let dataArray = null;

    // WebRTC Configuration
    const rtcConfig = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun2.l.google.com:19302" },
        { urls: "stun:stun3.l.google.com:19302" },
        { urls: "stun:stun4.l.google.com:19302" },
        { 
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject"
        }
      ],
      iceTransportPolicy: "all",
      rtcpMuxPolicy: "require"
    };

    // Initialize Monaco Editor
    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.34.1/min/vs' }});
    require(["vs/editor/editor.main"], function () {
      editor = monaco.editor.create(document.getElementById("editor"), {
        value: "# Welcome to SIREN Collaborative Editor\n# Start coding in Python...\n\n# Example: Input-driven code\nname = input('Enter your name: ')\nprint(f'Hello, {name}!')\n\n# Example: Calculator\nnum1 = float(input('Enter first number: '))\nnum2 = float(input('Enter second number: '))\nprint(f'Sum: {num1 + num2}')\n\n# Example: Multiple inputs\nprint('=== User Registration ===')\nname = input('Name: ')\nemail = input('Email: ')\nage = input('Age: ')\nprint(f'Registered: {name}, {email}, {age}')",
        language: "python",
        theme: "vs-dark",
        automaticLayout: true,
        readOnly: true,
        fontSize: 14,
        minimap: { enabled: false }
      });

      editor.onDidChangeModelContent(() => {
        if (mySid && mySid === writerId) {
          socket.emit("code_change", { session_id: sessionId, content: editor.getValue() });
        }
      });
    });

    // Socket connection management
    socket.on("connect", () => {
      mySid = socket.id;
      updateConnectionStatus(true, "Connected");
      socket.emit("join_session", { session_id: sessionId, name: myName });
      console.log("‚úÖ Connected to server with ID:", mySid);
      
      socket.emit("get_chat_history", { session_id: sessionId });
      initializeAudio();
    });

    socket.on("disconnect", () => {
      updateConnectionStatus(false, "Disconnected");
      console.log("‚ùå Disconnected from server");
      disconnectAudio();
    });

    function updateConnectionStatus(connected, message) {
      const statusDot = document.getElementById("statusDot");
      const statusText = document.getElementById("statusText");
      statusDot.className = `status-dot ${connected ? 'connected' : 'disconnected'}`;
      statusText.textContent = message;
    }

    // ==================== CODE EXECUTION WITH STATIC INPUT BOX ====================

    const staticInput = document.getElementById("staticInput");
    const sendInputBtn = document.getElementById("sendInputBtn");

    document.getElementById("runBtn").onclick = async () => {
        const output = document.getElementById("output");
        output.textContent = "üöÄ Starting code execution...\n";
        output.scrollTop = output.scrollHeight;
        
        const runBtn = document.getElementById("runBtn");
        runBtn.disabled = true;
        runBtn.textContent = "‚è≥ Running...";
        runBtn.classList.add("warning");
        
        // Enable input controls
        staticInput.disabled = false;
        sendInputBtn.disabled = false;
        staticInput.placeholder = "Type input for program...";
        staticInput.focus();
        
        try {
            const response = await fetch("/run_code", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ 
                    code: editor.getValue(), 
                    session_id: sessionId 
                })
            });
            
            const data = await response.json();
            
            if (data.status === "started") {
                currentProcessId = data.process_id;
                console.log("‚úÖ Code execution started with process ID:", currentProcessId);
                output.textContent += "Program started. Use the input box above to provide input.\n";
            } else if (data.status === "error") {
                output.textContent += `‚ùå ${data.message}\n`;
                resetExecutionState();
            } else {
                output.textContent += "‚ùå Unexpected response from server\n";
                resetExecutionState();
            }
        } catch (error) {
            output.textContent += `‚ùå Network error: ${error.message}\n`;
            resetExecutionState();
        }
    };

    // Handle sending input from static input box
    sendInputBtn.addEventListener("click", sendStaticInput);
    
    staticInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
            sendStaticInput();
        }
    });

    function sendStaticInput() {
        const userInput = staticInput.value.trim();
        
        if (!userInput) {
            return;
        }
        
        if (!currentProcessId) {
            const output = document.getElementById("output");
            output.textContent += "‚ùå No program is currently running\n";
            return;
        }
        
        const output = document.getElementById("output");
        output.textContent += `üì• [Input]: ${userInput}\n`;
        output.scrollTop = output.scrollHeight;
        
        // Send input to the backend process
        fetch("/provide_input", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ 
                user_input: userInput,
                process_id: currentProcessId
            })
        }).then(response => response.json())
          .then(data => {
              if (data.status === "success") {
                  console.log("‚úÖ Input sent successfully");
                  staticInput.value = ""; // Clear input field
                  staticInput.focus();
              } else {
                  output.textContent += `‚ùå ${data.message}\n`;
              }
          })
          .catch(error => {
              output.textContent += `‚ùå Error sending input: ${error.message}\n`;
          });
    }

    // Handle real-time code output
    socket.on("code_output", (data) => {
        if (data.process_id === currentProcessId) {
            const output = document.getElementById("output");
            output.textContent += data.output;
            output.scrollTop = output.scrollHeight;
        }
    });

    // Handle code completion
    socket.on("code_complete", (data) => {
        if (data.process_id === currentProcessId) {
            const output = document.getElementById("output");
            output.textContent += "\n‚úÖ Program execution completed\n";
            output.scrollTop = output.scrollHeight;
            
            resetExecutionState();
        }
    });

    function resetExecutionState() {
        const runBtn = document.getElementById("runBtn");
        runBtn.disabled = false;
        runBtn.textContent = "‚ñ∂ Run Code";
        runBtn.classList.remove("warning");
        
        // Disable input controls
        staticInput.disabled = true;
        sendInputBtn.disabled = true;
        staticInput.value = "";
        staticInput.placeholder = "Run code to enable input...";
        
        currentProcessId = null;
    }

    document.getElementById("clearBtn").onclick = () => {
        document.getElementById("output").textContent = "";
        resetExecutionState();
    };

    // ==================== CHAT FUNCTIONALITY ====================

    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const tabName = btn.getAttribute('data-tab');
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
        });
    });

    const chatInput = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const chatMessages = document.getElementById('chatMessages');

    function sendChatMessage() {
        const message = chatInput.value.trim();
        if (!message) return;
        
        socket.emit("send_chat_message", {
            session_id: sessionId,
            message: message
        });
        
        chatInput.value = '';
        chatInput.focus();
    }

    sendChatBtn.addEventListener('click', sendChatMessage);
    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendChatMessage();
        }
    });

    socket.on("new_chat_message", (messageData) => {
        addChatMessage(messageData);
    });

    socket.on("chat_history", (data) => {
        chatMessages.innerHTML = '';
        if (data.messages && data.messages.length > 0) {
            data.messages.forEach(message => {
                addChatMessage(message);
            });
        } else {
            chatMessages.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">No messages yet. Start a conversation!</div>';
        }
    });

    function addChatMessage(messageData) {
        const isMe = messageData.sender_sid === mySid;
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${isMe ? 'me' : 'other'}`;
        
        messageDiv.innerHTML = `
            ${!isMe ? `<div class="message-sender">${messageData.sender_name}</div>` : ''}
            <div class="message-text">${escapeHtml(messageData.message)}</div>
            <div class="message-time">${messageData.time_display || formatTime(messageData.timestamp)}</div>
        `;
        
        const placeholder = chatMessages.querySelector('div[style*="text-align: center"]');
        if (placeholder) {
            placeholder.remove();
        }
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatTime(timestamp) {
        const date = new Date(timestamp * 1000);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
    }

    // ==================== PARTICIPANTS MANAGEMENT ====================

    socket.on("participants_update", data => {
        const plist = document.getElementById("plist");
        plist.innerHTML = "";
        
        writerId = data.writer_id;
        hostId = data.host_id;

        let participantCount = 0;

        for (const [sid, info] of Object.entries(data.participants)) {
            participantCount++;
            
            const li = document.createElement("li");
            
            const infoDiv = document.createElement("div");
            infoDiv.className = "participant-info";
            
            const nameSpan = document.createElement("span");
            nameSpan.className = "participant-name";
            nameSpan.textContent = info.name + (sid === mySid ? " (You)" : "");
            
            const roleSpan = document.createElement("span");
            roleSpan.className = "participant-role";
            
            let roleText = "";
            if (sid === hostId) roleText += "üëë Host";
            if (sid === writerId) roleText += " ‚úèÔ∏è Writer";
            if (!roleText) roleText = "Participant";
            
            roleSpan.textContent = roleText;
            
            const audioDiv = document.createElement("div");
            audioDiv.className = "participant-audio";
            
            const audioIndicator = document.createElement("div");
            audioIndicator.className = "audio-indicator";
            audioIndicator.id = `audio-indicator-${sid}`;
            
            const audioStatus = document.createElement("span");
            audioStatus.textContent = "Connected";
            audioStatus.style.fontSize = "10px";
            audioStatus.style.color = "#9ca3af";
            
            audioDiv.appendChild(audioIndicator);
            audioDiv.appendChild(audioStatus);
            
            infoDiv.appendChild(nameSpan);
            infoDiv.appendChild(roleSpan);
            infoDiv.appendChild(audioDiv);

            const actionsDiv = document.createElement("div");
            actionsDiv.className = "participant-actions";
            
            if (mySid === hostId && sid !== mySid) {
                const grantBtn = document.createElement("button");
                grantBtn.className = "action-btn";
                grantBtn.textContent = sid === writerId ? "Revoke Write" : "Grant Write";
                grantBtn.onclick = () => {
                    if (sid === writerId) {
                        socket.emit("revoke_write", { session_id: sessionId });
                    } else {
                        socket.emit("grant_write", { session_id: sessionId, target_sid: sid });
                    }
                };
                actionsDiv.appendChild(grantBtn);
            }

            li.appendChild(infoDiv);
            li.appendChild(actionsDiv);
            plist.appendChild(li);
        }

        document.getElementById("participantCount").textContent = participantCount;

        if (editor) {
            const isWriter = mySid === writerId;
            editor.updateOptions({ readOnly: !isWriter });
            document.getElementById("writerBanner").style.display = isWriter ? "block" : "none";
        }

        if (isAudioConnected) {
            connectToNewParticipants(data.participants);
        }
    });

    function connectToNewParticipants(participants) {
        for (const [sid, info] of Object.entries(participants)) {
            if (sid !== mySid && !pcPeers[sid] && isAudioConnected) {
                createPeerConnection(sid, info.name);
            }
        }
    }

    // ==================== AUDIO FUNCTIONALITY ====================

    async function initializeAudio() {
        try {
            console.log("üé§ Auto-connecting audio...");
            localStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    channelCount: 1
                }
            });
            
            isAudioConnected = true;
            setupAudioVisualization();
            
            setTimeout(() => {
                socket.emit("get_participants", { session_id: sessionId });
            }, 1000);
            
            console.log("‚úÖ Audio auto-connected successfully");
            showAudioMessage("üé§ Voice chat is now active!");

        } catch (error) {
            console.error("‚ùå Failed to auto-connect audio:", error);
            showAudioMessage("‚ùå Could not access microphone. Please check browser permissions.");
        }
    }

    function setupAudioVisualization() {
        try {
            audioContext = new AudioContext();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(localStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            updateAudioLevel();
        } catch (error) {
            console.error("Audio visualization error:", error);
        }
    }

    function updateAudioLevel() {
        if (!analyser || !isAudioConnected) {
            audioLevelFill.style.width = "0%";
            requestAnimationFrame(updateAudioLevel);
            return;
        }
        
        analyser.getByteFrequencyData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
        }
        let average = sum / dataArray.length;
        let level = Math.min(100, (average / 128) * 100);
        audioLevelFill.style.width = level + "%";
        
        const myIndicator = document.getElementById(`audio-indicator-${mySid}`);
        if (myIndicator && !isMuted && level > 10) {
            myIndicator.classList.add('speaking');
        } else if (myIndicator) {
            myIndicator.classList.remove('speaking');
        }
        
        requestAnimationFrame(updateAudioLevel);
    }

    const muteButton = document.getElementById("muteButton");
    const muteIcon = document.getElementById("muteIcon");
    const muteText = document.getElementById("muteText");
    const audioLevelFill = document.getElementById("audioLevelFill");
    
    muteButton.addEventListener("click", toggleMute);

    function toggleMute() {
        if (!isAudioConnected) {
            showAudioMessage("‚ùå Audio is not connected.");
            return;
        }
        
        if (isMuted) {
            unmuteAudio();
        } else {
            muteAudio();
        }
    }

    function muteAudio() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = false;
            });
        }
        
        isMuted = true;
        muteButton.classList.add("muted");
        muteIcon.textContent = "üîá";
        muteText.textContent = "Unmute";
        audioLevelFill.style.width = "0%";
        showAudioMessage("üîá You are muted");
    }

    function unmuteAudio() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = true;
            });
        }
        
        isMuted = false;
        muteButton.classList.remove("muted");
        muteIcon.textContent = "üé§";
        muteText.textContent = "Mute";
        showAudioMessage("üé§ You are unmuted");
    }

    function showAudioMessage(message) {
        const output = document.getElementById("output");
        output.textContent = `[Audio] ${message}\n` + output.textContent;
        output.scrollTop = 0;
    }

    function disconnectAudio() {
        console.log("üé§ Disconnecting audio...");
        
        Object.values(pcPeers).forEach(pc => {
            pc.close();
        });
        pcPeers = {};
        
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        
        if (audioContext) {
            audioContext.close();
            audioContext = null;
        }
        
        isAudioConnected = false;
        audioLevelFill.style.width = "0%";
        
        console.log("‚úÖ Audio disconnected");
    }

    function createPeerConnection(peerId, peerName) {
        console.log(`üîó Creating peer connection to: ${peerName}`);
        
        const pc = new RTCPeerConnection(rtcConfig);
        pcPeers[peerId] = pc;

        if (localStream) {
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });
        }

        pc.ontrack = (event) => {
            console.log(`üéß Received audio stream from: ${peerName}`);
            const audioElement = document.createElement("audio");
            audioElement.autoplay = true;
            audioElement.controls = false;
            audioElement.style.display = "none";
            audioElement.srcObject = event.streams[0];
            document.body.appendChild(audioElement);
            
            addAudioParticipant(peerId, peerName, "connected");
            showAudioMessage(`üéß Connected to ${peerName}'s audio`);
        };

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit("webrtc_ice_candidate", {
                    target: peerId,
                    candidate: event.candidate
                });
            }
        };

        pc.onconnectionstatechange = () => {
            console.log(`Connection state with ${peerName}: ${pc.connectionState}`);
            if (pc.connectionState === 'connected') {
                updateAudioParticipantStatus(peerId, 'connected');
            } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                updateAudioParticipantStatus(peerId, 'disconnected');
            }
        };

        pc.createOffer()
            .then(offer => pc.setLocalDescription(offer))
            .then(() => {
                socket.emit("webrtc_offer", {
                    target: peerId,
                    sdp: pc.localDescription
                });
            })
            .catch(error => {
                console.error("Error creating offer:", error);
            });

        return pc;
    }

    function addAudioParticipant(peerId, peerName, status) {
        const existing = document.getElementById(`audio-${peerId}`);
        if (existing) {
            existing.remove();
        }

        const div = document.createElement("div");
        div.id = `audio-${peerId}`;
        div.className = "audio-participant";
        div.innerHTML = `
            <span>${peerName}</span>
            <span class="audio-status ${status}">${status}</span>
        `;
        audioList.appendChild(div);
        updateAudioCount();
    }

    function updateAudioParticipantStatus(peerId, status) {
        const element = document.getElementById(`audio-${peerId}`);
        if (element) {
            const statusEl = element.querySelector('.audio-status');
            statusEl.textContent = status;
            statusEl.className = `audio-status ${status}`;
        }
    }

    function updateAudioCount() {
        const count = Object.keys(pcPeers).length;
        peerCount.textContent = count;
        audioCount.textContent = `${count} user${count !== 1 ? 's' : ''}`;
    }

    // WebRTC signaling handlers
    socket.on("webrtc_offer", async (data) => {
        if (!isAudioConnected) return;
        
        const { sid, sdp } = data;
        let pc = pcPeers[sid];
        
        if (!pc) {
            pc = createPeerConnection(sid, "User");
        }
        
        try {
            await pc.setRemoteDescription(new RTCSessionDescription(sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            socket.emit("webrtc_answer", {
                target: sid,
                sdp: pc.localDescription
            });
        } catch (error) {
            console.error("Error handling offer:", error);
        }
    });

    socket.on("webrtc_answer", async (data) => {
        if (!isAudioConnected) return;
        
        const { sid, sdp } = data;
        const pc = pcPeers[sid];
        
        if (pc) {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
            } catch (error) {
                console.error("Error handling answer:", error);
            }
        }
    });

    socket.on("webrtc_ice_candidate", async (data) => {
        if (!isAudioConnected) return;
        
        const { sid, candidate } = data;
        const pc = pcPeers[sid];
        
        if (pc && candidate) {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (error) {
                console.error("Error adding ICE candidate:", error);
            }
        }
    });

    // ==================== UI HELPERS ====================

    document.getElementById("helpBtn").addEventListener("click", () => {
        alert(`SIREN Features:\n\nüí¨ Real-time chat\nüé§ Voice chat\nüêç Python code execution\nüì• Static input box (always available during execution)\nüë• Real-time collaboration\n\nHow to use:\n1. Click 'Run Code'\n2. Use the input box to provide program input\n3. Press Enter or click 'Send Input'`);
    });

    document.getElementById("settingsBtn").addEventListener("click", () => {
        alert(`Session Settings:\n\n‚Ä¢ Audio: ${isAudioConnected ? "Connected" : "Disconnected"}\n‚Ä¢ Mute: ${isMuted ? "On" : "Off"}\n‚Ä¢ Role: ${mySid === writerId ? "Writer" : "Viewer"}\n‚Ä¢ Code Execution: ${currentProcessId ? "Running" : "Ready"}\n‚Ä¢ Input Box: ${staticInput.disabled ? "Disabled" : "Enabled"}`);
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        disconnectAudio();
    });

    console.log("üöÄ SIREN with Static Input Box ready!");
  </script>
</body>
</html>